name: CD (self-hosted)
on:
  workflow_run:
    workflows: ["CI (Core)"]
    types: [completed]
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy_local:
    name: Deploy via Ansible on my machine
    runs-on: [self-hosted, Linux, X64]
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure prerequisites (Ansible, Docker)
        run: |
          set -e
          if ! command -v ansible-playbook >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y ansible
          fi
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y docker.io
            sudo usermod -aG docker $USER || true
          fi
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get install -y docker-compose
          fi

      - name: Write fresh .env from Secrets (overwrite each run)
        run: |
          : > .env
          printf "OPENAI_API_KEY=%s\n" "${{ secrets.OPENAI_API_KEY }}" >> .env
          printf "TELEGRAM_BOT_TOKEN=%s\n" "${{ secrets.TELEGRAM_BOT_TOKEN }}" >> .env
          printf "GENIUS_ACCESS_TOKEN=%s\n" "${{ secrets.GENIUS_ACCESS_TOKEN }}" >> .env
          printf "TELEGRAM_CHAT_ID=%s\n" "${{ secrets.TELEGRAM_CHAT_ID }}" >> .env
          printf "DATABASE_URL=%s\n" "${{ secrets.DATABASE_URL }}" >> .env
          sed -E 's/(=).+/\1*****/' .env

      - name: Create runtime inventory (localhost)
        working-directory: devops/ansible
        run: |
          mkdir -p runtime
          cat > runtime/hosts.ini <<'EOF'
          [target]
          127.0.0.1 ansible_connection=local
          EOF
          cat runtime/hosts.ini

      - name: Create minimal runtime playbook
        working-directory: devops/ansible
        run: |
          cat > runtime/deploy_local.yml <<'YAML'
          ---
          - name: Local deploy via docker compose
            hosts: target
            gather_facts: false
            vars:
              project_dir: "{{ lookup('env','GITHUB_WORKSPACE') | default(ansible_env.PWD, true) }}"
              compose_file: "{{ project_dir }}/devops/compose/docker-compose.prod.yml"
            tasks:
              - name: docker compose up -d --build (prod)
                command: docker compose -f "{{ compose_file }}" up -d --build
                args: { chdir: "{{ project_dir }}" }
          YAML
          cat runtime/deploy_local.yml

      - name: Deploy (Ansible ‚Üí docker compose up)
        working-directory: devops/ansible
        run: ansible-playbook -i runtime/hosts.ini runtime/deploy_local.yml

      - name: Wait for health=healthy
        env:
          SVC: app
        run: |
          set -e
          CID="$(docker ps --format '{{.ID}}\t{{.Names}}' | awk -v s="$SVC" '$2 ~ "-"s"-" {print $1; exit}')"
          if [ -z "$CID" ]; then echo "Container not found"; exit 1; fi
          echo "Waiting for healthy: $CID"
          for i in {1..60}; do
            HS="$(docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null || echo 'unknown')"
            echo "[$i] health=$HS"
            [ "$HS" = "healthy" ] && exit 0
            sleep 2
          done
          echo "Timeout waiting for healthy"; docker logs --tail=80 "$CID"; exit 1

      - name: Tail logs (masked) + artifact
        id: logs
        run: |
          CID="$(docker ps --format '{{.ID}}\t{{.Names}}' | awk '$2 ~ /-app-/ {print $1; exit}')"
          [ -n "$CID" ] || exit 0
          docker logs --tail=80 "$CID" 2>&1 \
            | sed -E 's/(sk-[A-Za-z0-9_-]+)/sk-*****/g' \
            | sed -E 's/([0-9]{9,}:[A-Za-z0-9_-]{20,})/**token**/g' \
            | tee cd-logs.txt
          echo "logfile=cd-logs.txt" >> $GITHUB_OUTPUT
      - uses: actions/upload-artifact@v4
        if: ${{ always() && steps.logs.outputs.logfile != '' }}
        with:
          name: cd-logs
          path: cd-logs.txt
          if-no-files-found: ignore

      - name: üì§ CD Notify (Success)
        if: success()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN_TEST_NOTIFIER }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
          RUN_URL:  https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BRANCH:   ${{ github.ref_name }}
        run: |
          if [ -z "$TG_TOKEN" ] || [ -z "$TG_CHAT" ]; then echo "No TG secrets; skip"; exit 0; fi
          TEXT="üöÄ CD (${BRANCH}): SUCCESS ‚úÖ
          ü§ñ Bot-’® RUNNING ’ß (healthy)"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode chat_id="${TG_CHAT}" \
            --data-urlencode parse_mode="HTML" \
            --data-urlencode text="${TEXT}" \
            --data-urlencode reply_markup='{"inline_keyboard":[[{"text":"üìÑ View CD logs","url":"'"${RUN_URL}"'"}]]}'

      - name: ‚ùå CD Notify (Failure)
        if: failure()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN_TEST_NOTIFIER }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
          RUN_URL:  https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BRANCH:   ${{ github.ref_name }}
        run: |
          if [ -z "$TG_TOKEN" ] || [ -z "$TG_CHAT" ]; then echo "No TG secrets; skip"; exit 0; fi
          TEXT="üî• CD (${BRANCH}): FAILURE ‚ùå"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode chat_id="${TG_CHAT}" \
            --data-urlencode parse_mode="HTML" \
            --data-urlencode text="${TEXT}" \
            --data-urlencode reply_markup='{"inline_keyboard":[[{"text":"üìÑ View CD logs","url":"'"${RUN_URL}"'"}]]}'
