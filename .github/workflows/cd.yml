name: CD (self-hosted)

on:
  workflow_run:
    workflows: ["CI (Core)"]
    types: [completed]
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy_local:
    name: Deploy via Ansible on my machine
    runs-on: [self-hosted, Linux, X64]
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}

    env:
      PROJECT_PROD: smartpromptbox_prod
      PROJECT_DEV:  smartpromptbox_dev
      COMPOSE_PROD: devops/compose/docker-compose.prod.yml
      COMPOSE_DEV:  devops/compose/docker-compose.dev.yml

    steps:
      - name: Pre-clean root-owned leftovers
        run: |
          set -euxo pipefail
          REPO="${GITHUB_REPOSITORY##*/}"
          CANDIDATES=(
            "${RUNNER_WORKSPACE}/${REPO}/${REPO}"
            "${RUNNER_WORKSPACE}/${REPO}"
          )
          for BASE in "${CANDIDATES[@]}"; do
            [ -d "$BASE" ] || continue
            sudo rm -f  "$BASE/db/memory.db" || true
            sudo rm -rf "$BASE/devops/ansible/runtime" || true
            sudo rm -f  "$BASE/.env" "$BASE/cd-logs.txt" || true
            sudo chown -R "$USER:$USER" "$BASE" || true
          done

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          clean: false

      - name: Ensure prerequisites (Ansible, Docker)
        run: |
          set -e
          if ! command -v ansible-playbook >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y ansible
          fi
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y docker.io
          fi
          # Docker Compose v2 (plugin), ’∏’π ’©’• ’∞’´’∂ docker-compose v1
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get install -y docker-compose-plugin
          fi

      - name: Ensure dev stack is not running (optional)
        run: |
          sudo docker compose -p "$PROJECT_DEV" -f "$COMPOSE_DEV" down --remove-orphans || true

      - name: Write fresh .env from Secrets (overwrite each run)
        run: |
          : > .env
          printf "OPENAI_API_KEY=%s\n"                   "${{ secrets.OPENAI_API_KEY }}"                   >> .env
          printf "TELEGRAM_BOT_TOKEN=%s\n"               "${{ secrets.TELEGRAM_BOT_TOKEN }}"               >> .env
          printf "GENIUS_ACCESS_TOKEN=%s\n"              "${{ secrets.GENIUS_ACCESS_TOKEN }}"              >> .env
          printf "TELEGRAM_CHAT_ID=%s\n"                 "${{ secrets.TELEGRAM_CHAT_ID }}"                 >> .env
          printf "DATABASE_URL=%s\n"                     "${{ secrets.DATABASE_URL }}"                     >> .env
          sed -E 's/(=).+/\1*****/' .env || true

      - name: Create runtime inventory (localhost)
        working-directory: devops/ansible
        run: |
          mkdir -p runtime
          cat > runtime/hosts.ini <<'EOF'
          [target]
          127.0.0.1 ansible_connection=local
          EOF

      - name: Create minimal runtime playbook
        working-directory: devops/ansible
        run: |
          cat > runtime/deploy_local.yml <<'YAML'
          ---
          - name: Local deploy via docker compose
            hosts: target
            gather_facts: false
            vars:
              project_dir: "{{ lookup('env','GITHUB_WORKSPACE') | default(ansible_env.PWD, true) }}"
              compose_file: "{{ project_dir }}/devops/compose/docker-compose.prod.yml"
              project_name: "smartpromptbox_prod"
            tasks:
              - name: docker compose up -d --build (prod)
                become: true
                command: docker compose -p "{{ project_name }}" -f "{{ compose_file }}" up -d --build --remove-orphans
                args:
                  chdir: "{{ project_dir }}"
          YAML

      - name: Deploy (Ansible ‚Üí docker compose up)
        working-directory: devops/ansible
        run: ansible-playbook -i runtime/hosts.ini runtime/deploy_local.yml

      - name: Wait for health=healthy
        run: |
          set -e
          sudo docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" ps
          CID="$(sudo docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" ps -q app || true)"
          if [ -z "$CID" ]; then
            echo "Container not found"; exit 1
          fi
          echo "Waiting for healthy: $CID"
          for i in {1..60}; do
            HS="$(sudo docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null || echo 'unknown')"
            echo "[$i] health=$HS"
            [ "$HS" = "healthy" ] && exit 0
            sleep 2
          done
          echo "Timeout waiting for healthy"; sudo docker logs --tail=200 "$CID" || true; exit 1

      - name: Tail logs (masked) + artifact
        id: logs
        run: |
          CID="$(sudo docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" ps -q app || true)"
          [ -n "$CID" ] || exit 0
          sudo docker logs --tail=200 "$CID" 2>&1 \
            | sed -E 's/(sk-[A-Za-z0-9_-]+)/sk-*****/g' \
            | sed -E 's/([0-9]{9,}:[A-Za-z0-9_-]{20,})/**token**/g' \
            | tee cd-logs.txt
          echo "logfile=cd-logs.txt" >> $GITHUB_OUTPUT

      - uses: actions/upload-artifact@v4
        if: ${{ always() && steps.logs.outputs.logfile != '' }}
        with:
          name: cd-logs
          path: cd-logs.txt
          if-no-files-found: ignore

      - name: üì§ CD Notify (Success)
        if: success()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN_TEST_NOTIFIER }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
          RUN_URL:  https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BRANCH:   ${{ github.ref_name }}
        run: |
          if [ -z "$TG_TOKEN" ] || [ -z "$TG_CHAT" ]; then echo "No TG secrets; skip"; exit 0; fi
          TEXT="üöÄ CD (${BRANCH}): SUCCESS ‚úÖ
          ü§ñ Bot-’® RUNNING ’ß (healthy)"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode chat_id="${TG_CHAT}" \
            --data-urlencode parse_mode="HTML" \
            --data-urlencode text="${TEXT}" \
            --data-urlencode reply_markup='{"inline_keyboard":[[{"text":"üìÑ View CD logs","url":"'"${RUN_URL}"'"}]]}'

      - name: ‚ùå CD Notify (Failure)
        if: failure()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN_TEST_NOTIFIER }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
          RUN_URL:  https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BRANCH:   ${{ github.ref_name }}
        run: |
          if [ -z "$TG_TOKEN" ] || [ -z "$TG_CHAT" ]; then echo "No TG secrets; skip"; exit 0; fi
          TEXT="üî• CD (${BRANCH}): FAILURE ‚ùå"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode chat_id="${TG_CHAT}" \
            --data-urlencode parse_mode="HTML" \
            --data-urlencode text="${TEXT}" \
            --data-urlencode reply_markup='{"inline_keyboard":[[{"text":"üìÑ View CD logs","url":"'"${RUN_URL}"'"}]]}'
