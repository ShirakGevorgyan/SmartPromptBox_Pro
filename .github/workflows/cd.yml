name: CD (self-hosted)

on:
  workflow_run:
    workflows: ["CI (Core)"]
    types: [completed]
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy_local:
    name: Deploy on my self-hosted runner (no Ansible)
    runs-on: [self-hosted, Linux, X64]
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run && github.event.workflow_run.conclusion == 'success') }}
    timeout-minutes: 45

    env:
      PROJECT_PROD: smartpromptbox_prod
      PROJECT_DEV:  smartpromptbox_dev
      COMPOSE_PROD: devops/compose/docker-compose.prod.yml
      COMPOSE_DEV:  devops/compose/docker-compose.dev.yml
      DOCKER_BUILDKIT: "1"
      COMPOSE_DOCKER_CLI_BUILD: "1"

    steps:
      # ---- fix EACCES from previous root-owned files
      - name: Pre-clean root-owned leftovers (fast, safe)
        run: |
          set -euxo pipefail
          REPO="${GITHUB_REPOSITORY##*/}"
          CANDIDATES=(
            "${RUNNER_WORKSPACE}/${REPO}/${REPO}"
            "${RUNNER_WORKSPACE}/${REPO}"
          )
          for BASE in "${CANDIDATES[@]}"; do
            [ -d "$BASE" ] || continue
            sudo rm -f  "$BASE/db/memory.db" || true
            sudo rm -rf "$BASE/devops/ansible/runtime" || true
            sudo rm -f  "$BASE/.env" "$BASE/cd-logs.txt" || true
            sudo chown -R "$USER:$USER" "$BASE" || true
          done

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          clean: false

      - name: Ensure dev stack is not running (optional)
        run: docker compose -p "$PROJECT_DEV" -f "$COMPOSE_DEV" down --remove-orphans || true

      - name: Docker sanity
        run: |
          docker version
          docker compose version
          id

      - name: Write fresh .env from Secrets
        run: |
          : > .env
          printf "OPENAI_API_KEY=%s\n"        "${{ secrets.OPENAI_API_KEY }}"        >> .env
          printf "TELEGRAM_BOT_TOKEN=%s\n"    "${{ secrets.TELEGRAM_BOT_TOKEN }}"    >> .env
          printf "GENIUS_ACCESS_TOKEN=%s\n"   "${{ secrets.GENIUS_ACCESS_TOKEN }}"   >> .env
          printf "TELEGRAM_CHAT_ID=%s\n"      "${{ secrets.TELEGRAM_CHAT_ID }}"      >> .env
          printf "DATABASE_URL=%s\n"          "${{ secrets.DATABASE_URL }}"          >> .env
          echo "Wrote .env (masked):"
          sed -E 's/(=).+/\1*****/' .env || true

      - name: Compose config (prod)
        run: docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" config

      - name: Build image (prod) with logs
        run: docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" build --pull --progress=plain

      - name: Up (prod)
        run: docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" up -d --remove-orphans

      - name: Wait for health=healthy
        env:
          SVC: app
        run: |
          set -e
          CID="$(docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" ps -q "$SVC" || true)"
          if [ -z "$CID" ]; then
            echo "Container not found"; docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" ps; exit 1
          fi
          echo "Waiting for healthy: $CID"
          for i in {1..120}; do
            HS="$(docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null || echo 'unknown')"
            echo "[$i] health=$HS"
            [ "$HS" = "healthy" ] && exit 0
            sleep 2
          done
          echo "Timeout waiting for healthy"
          docker logs --tail=300 "$CID" || true
          exit 1

      - name: Tail logs (masked) + artifact
        id: logs
        run: |
          CID="$(docker compose -p "$PROJECT_PROD" -f "$COMPOSE_PROD" ps -q app || true)"
          [ -n "$CID" ] || exit 0
          docker logs --tail=300 "$CID" 2>&1 \
            | sed -E 's/(sk-[A-Za-z0-9_-]+)/sk-*****/g' \
            | sed -E 's/([0-9]{9,}:[A-Za-z0-9_-]{20,})/**token**/g' \
            | tee cd-logs.txt
          echo "logfile=cd-logs.txt" >> $GITHUB_OUTPUT

      - uses: actions/upload-artifact@v4
        if: ${{ always() && steps.logs.outputs.logfile != '' }}
        with:
          name: cd-logs
          path: cd-logs.txt
          if-no-files-found: ignore

      - name: üì§ CD Notify (Success)
        if: success()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN_TEST_NOTIFIER }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
          RUN_URL:  https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BRANCH:   ${{ github.ref_name }}
        run: |
          [ -z "$TG_TOKEN" -o -z "$TG_CHAT" ] && exit 0
          TEXT="üöÄ CD (${BRANCH}): SUCCESS ‚úÖ
          ü§ñ Bot-’® RUNNING ’ß (healthy)"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode chat_id="${TG_CHAT}" \
            --data-urlencode parse_mode="HTML" \
            --data-urlencode text="${TEXT}" \
            --data-urlencode reply_markup='{"inline_keyboard":[[{"text":"üìÑ View CD logs","url":"'"${RUN_URL}"'"}]]}'

      - name: ‚ùå CD Notify (Failure)
        if: failure()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN_TEST_NOTIFIER }}
          TG_CHAT:  ${{ secrets.TELEGRAM_CHAT_ID }}
          RUN_URL:  https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BRANCH:   ${{ github.ref_name }}
        run: |
          [ -z "$TG_TOKEN" -o -z "$TG_CHAT" ] && exit 0
          TEXT="üî• CD (${BRANCH}): FAILURE ‚ùå"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode chat_id="${TG_CHAT}" \
            --data-urlencode parse_mode="HTML" \
            --data-urlencode text="${TEXT}" \
            --data-urlencode reply_markup='{"inline_keyboard":[[{"text":"üìÑ View CD logs","url":"'"${RUN_URL}"'"}]]}'
